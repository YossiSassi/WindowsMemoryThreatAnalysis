<#
.SYNOPSIS
    Comprehensive memory threat analysis script for process memory region JSON data.
    Use 'Get-RWXAndMapThreads.ps1' to generate the input json file.

.DESCRIPTION
    Analyzes JSON output from memory scanning tools (e.g., Get-RWXAndMapThreads) to detect
    suspicious patterns including: RWX regions, MZ/PE headers, NOP sleds, syscall stubs,
    trampolines, INT3 patterns, high-entropy regions, suspicious strings, and active threads.
    Generates a per-process risk assessment and outputs an HTML report.
    Uses an input json file generated by 'Get-RWXAndMapThreads.ps1' script.

.PARAMETER JsonFilePath
    Path to the memory.json file to analyze. Defaults to memory.json in the script directory.

.PARAMETER HtmlReportPath
    Path for the HTML report output. Defaults to findings.htm in the script directory.

.PARAMETER RiskThreshold
    Minimum risk score to flag a process as high-risk. Default: 500.

.EXAMPLE
    .\Invoke-MemoryThreatAnalysis.ps1
    .\Invoke-MemoryThreatAnalysis.ps1 -JsonFilePath C:\data\memory.json -HtmlReportPath C:\reports\findings.htm

.NOTES
    Requires Python 3.x for JSON parsing of large/concatenated JSON arrays.
    Author: Claude Opus 4.6 - Memory Threat Analyzer
    Prompt design & AI implementation plan: #yossi_sassi (yossis@protonmail.com)
    v1.0
#>

[CmdletBinding()]
param(
    [Parameter()]
    [string]$JsonFilePath = (Join-Path $PSScriptRoot 'memory.json'),

    [Parameter()]
    [string]$HtmlReportPath = (Join-Path $PSScriptRoot 'findings.htm'),

    [Parameter()]
    [int]$RiskThreshold = 500
)

$ErrorActionPreference = 'Stop'

# ============================================================================
# HELPER FUNCTIONS
# ============================================================================

function Write-Banner {
    param([string]$Title, [string]$Char = '=', [int]$Width = 78)
    $line = $Char * $Width
    Write-Host "`n$line" -ForegroundColor Cyan
    Write-Host "  $Title" -ForegroundColor Cyan
    Write-Host "$line" -ForegroundColor Cyan
}

function Write-Finding {
    param([string]$Severity, [string]$Message)
    $color = switch ($Severity) {
        'CRITICAL' { 'Red' }
        'HIGH'     { 'Magenta' }
        'MEDIUM'   { 'Yellow' }
        'LOW'      { 'Green' }
        'INFO'     { 'Gray' }
        default    { 'White' }
    }
    Write-Host "  [$Severity] $Message" -ForegroundColor $color
}

function Extract-HexBytes {
    param([string]$HexSample)
    $bytes = [System.Collections.Generic.List[int]]::new()
    if (-not $HexSample) { return $bytes }
    foreach ($line in $HexSample.Split("`n")) {
        $trimmed = $line.Trim()
        if (-not $trimmed -or $trimmed -notmatch '^\s*[0-9a-fA-F]+:') { continue }
        if ($trimmed -match '^\s*[0-9a-fA-F]+:\s+((?:[0-9A-Fa-f]{2}\s+)+)') {
            $hexPart = $Matches[1].Trim()
            foreach ($byteStr in $hexPart.Split(' ', [StringSplitOptions]::RemoveEmptyEntries)) {
                if ($byteStr.Length -eq 2) {
                    try { [void]$bytes.Add([Convert]::ToInt32($byteStr, 16)) } catch {}
                }
            }
        }
    }
    return $bytes
}

function Get-ShannonEntropy {
    param([System.Collections.Generic.List[int]]$Bytes)
    if ($Bytes.Count -lt 16) { return 0.0 }
    $freq = @{}
    foreach ($b in $Bytes) {
        if ($freq.ContainsKey($b)) { $freq[$b]++ } else { $freq[$b] = 1 }
    }
    $entropy = 0.0
    $total = $Bytes.Count
    foreach ($count in $freq.Values) {
        $p = $count / $total
        if ($p -gt 0) { $entropy -= $p * [Math]::Log($p, 2) }
    }
    return $entropy
}

# ============================================================================
# STEP 1: PARSE JSON
# ============================================================================

Write-Banner "STEP 1: LOADING AND PARSING JSON"

if (-not (Test-Path $JsonFilePath)) {
    Write-Error "File not found: $JsonFilePath"
    return
}

$fileSize = (Get-Item $JsonFilePath).Length
Write-Host "  File: $JsonFilePath ($([Math]::Round($fileSize/1MB, 2)) MB)" -ForegroundColor Gray

# Use Python for reliable parsing of large concatenated JSON arrays
$pyScript = @'
import json, re, sys
with open(sys.argv[1], 'r', encoding='utf-8-sig') as f:
    raw = f.read()
data = []
decoder = json.JSONDecoder()
pos = 0
s = raw.lstrip()
while pos < len(s):
    while pos < len(s) and s[pos] in ' \t\r\n': pos += 1
    if pos >= len(s): break
    try:
        obj, end_pos = decoder.raw_decode(s, pos)
        if isinstance(obj, list): data.extend(obj)
        else: data.append(obj)
        pos = end_pos
    except json.JSONDecodeError:
        break
# Output as single JSON array to stdout
json.dump(data, sys.stdout, separators=(',',':'))
'@

$pyTempFile = [System.IO.Path]::GetTempFileName() + '.py'
$jsonTempFile = [System.IO.Path]::GetTempFileName() + '.json'
try {
    [System.IO.File]::WriteAllText($pyTempFile, $pyScript)
    Write-Host "  Parsing with Python..." -ForegroundColor Gray

    $proc = Start-Process -FilePath 'python' -ArgumentList "`"$pyTempFile`" `"$JsonFilePath`"" `
        -RedirectStandardOutput $jsonTempFile -RedirectStandardError ([System.IO.Path]::GetTempFileName()) `
        -NoNewWindow -Wait -PassThru

    if ($proc.ExitCode -ne 0) {
        Write-Error "Python parsing failed. Ensure Python 3.x is installed."
        return
    }

    Write-Host "  Loading parsed JSON into PowerShell..." -ForegroundColor Gray
    Add-Type -AssemblyName System.Web.Extensions
    $serializer = New-Object System.Web.Script.Serialization.JavaScriptSerializer
    $serializer.MaxJsonLength = [int]::MaxValue
    $rawJson = [System.IO.File]::ReadAllText($jsonTempFile)
    $entries = $serializer.DeserializeObject($rawJson)

    Write-Host "  Loaded $($entries.Count) entries successfully." -ForegroundColor Green
}
finally {
    Remove-Item $pyTempFile -ErrorAction SilentlyContinue
    Remove-Item $jsonTempFile -ErrorAction SilentlyContinue
}

$totalEntries = $entries.Count

# ============================================================================
# STEP 2: BASIC STATISTICS
# ============================================================================

Write-Banner "STEP 2: BASIC STATISTICS"

$processes = @{}
$protectionTypes = @{}

foreach ($e in $entries) {
    $proc = $e['ImageName']
    $prot = $e['TypeLabel']
    $ProcessID  = $e['ProcessID']

    if (-not $processes.ContainsKey($proc)) {
        $processes[$proc] = @{ Regions = 0; PIDs = [System.Collections.Generic.HashSet[int]]::new(); RWX = 0; ExecOnly = 0; TotalSize = 0 }
    }
    $processes[$proc].Regions++
    [void]$processes[$proc].PIDs.Add($processID)
    $processes[$proc].TotalSize += $e['RegionSize']
    if ($e['Protect'] -eq '0x40') { $processes[$proc].RWX++ } else { $processes[$proc].ExecOnly++ }

    if (-not $protectionTypes.ContainsKey($prot)) { $protectionTypes[$prot] = 0 }
    $protectionTypes[$prot]++
}

$totalProcesses = $processes.Count
Write-Host "  Total entries  : $totalEntries"
Write-Host "  Unique processes: $totalProcesses"
Write-Host ""
Write-Host "  Protection types:" -ForegroundColor White
foreach ($kv in $protectionTypes.GetEnumerator() | Sort-Object Value -Descending) {
    Write-Host "    $($kv.Key): $($kv.Value)"
}

Write-Host ""
Write-Host "  Per-process summary:" -ForegroundColor White
Write-Host ("  {0,-30} {1,8} {2,8} {3,8} {4,12}" -f 'Process', 'Regions', 'ExecOnly', 'RWX', 'TotalSize')
Write-Host ("  " + ('-' * 70))
foreach ($kv in $processes.GetEnumerator() | Sort-Object { $_.Value.Regions } -Descending) {
    $r = $kv.Value
    Write-Host ("  {0,-30} {1,8} {2,8} {3,8} {4,12}" -f $kv.Key, $r.Regions, $r.ExecOnly, $r.RWX, "$([Math]::Round($r.TotalSize/1KB))KB")
}

# ============================================================================
# STEP 3: THREAD ANALYSIS
# ============================================================================

Write-Banner "STEP 3: THREAD ANALYSIS"

$entriesWithThreads = @()
foreach ($e in $entries) {
    $threads = $e['Threads']
    if ($threads -and $threads.Count -gt 0) {
        $entriesWithThreads += $e
    }
}

if ($entriesWithThreads.Count -eq 0) {
    Write-Finding 'INFO' "No active threads found in any scanned memory regions."
    Write-Finding 'INFO' "This is a positive indicator - no in-progress code injection detected."
} else {
    Write-Finding 'CRITICAL' "$($entriesWithThreads.Count) regions have active threads!"
    foreach ($e in $entriesWithThreads) {
        Write-Host "    Process=$($e['ImageName']) PID=$($e['ProcessID']) Base=$($e['BaseAddress']) Type=$($e['TypeLabel'])"
        foreach ($t in $e['Threads']) {
            Write-Host "      ThreadID=$($t['ThreadId']) StartAddr=$($t['StartAddress'])"
        }
    }
}

# ============================================================================
# STEP 4: RWX ANALYSIS
# ============================================================================

Write-Banner "STEP 4: RWX (PAGE_EXECUTE_READWRITE) ANALYSIS"

$rwxEntries = @($entries | Where-Object { $_['Protect'] -eq '0x40' })
$execOnlyEntries = @($entries | Where-Object { $_['Protect'] -eq '0x20' })

Write-Host "  RWX regions: $($rwxEntries.Count) / $totalEntries ($([Math]::Round($rwxEntries.Count/$totalEntries*100,1))%)"
Write-Host "  EXEC-ONLY regions: $($execOnlyEntries.Count)"

# ============================================================================
# STEP 5: BYTE PATTERN ANALYSIS
# ============================================================================

Write-Banner "STEP 5: BYTE PATTERN ANALYSIS"

$mzHeaders = [System.Collections.Generic.List[object]]::new()
$nopSleds = [System.Collections.Generic.List[object]]::new()
$syscallStubs = [System.Collections.Generic.List[object]]::new()
$trampolineEntries = [System.Collections.Generic.List[object]]::new()
$int3Patterns = [System.Collections.Generic.List[object]]::new()
$highEntropyEntries = [System.Collections.Generic.List[object]]::new()
$allNullEntries = [System.Collections.Generic.List[object]]::new()
$rwxActiveEntries = [System.Collections.Generic.List[object]]::new()
$stringFindings = @{}

$suspiciousStrings = @(
    'http://', 'https://', 'cmd.exe', 'powershell', 'VirtualAlloc', 'VirtualProtect',
    'CreateThread', 'LoadLibrary', 'GetProcAddress', 'WriteProcessMemory',
    'NtAllocateVirtual', 'amsi', 'ntdll', 'kernel32', 'WinExec', 'ShellExecute',
    'mimikatz', 'beacon', 'cobalt', 'metasploit', 'meterpreter',
    'CreateRemoteThread', 'NtCreateThreadEx', 'password', 'encrypt',
    'socket', 'connect', 'WSAStartup'
)

$counter = 0
$total = $entries.Count

foreach ($e in $entries) {
    $counter++
    if ($counter % 500 -eq 0) { Write-Host "  Processing entry $counter / $total..." -ForegroundColor Gray }

    $hexSample = $e['HexSample']
    $rawBytes = Extract-HexBytes $hexSample

    if ($rawBytes.Count -eq 0) { continue }

    # All-null check
    $allNull = $true
    foreach ($b in $rawBytes) { if ($b -ne 0) { $allNull = $false; break } }
    if ($allNull) {
        [void]$allNullEntries.Add($e)
        if ($e['Protect'] -eq '0x40') { [void]$rwxActiveEntries.Add($e) }  # still count as RWX
        continue
    }

    # Track active RWX
    if ($e['Protect'] -eq '0x40') { [void]$rwxActiveEntries.Add($e) }

    # MZ header (PE file)
    if ($rawBytes.Count -ge 2 -and $rawBytes[0] -eq 0x4D -and $rawBytes[1] -eq 0x5A) {
        [void]$mzHeaders.Add($e)
    }

    # NOP sled (4+ consecutive 0x90)
    $nopCount = 0; $maxNops = 0
    foreach ($b in $rawBytes) {
        if ($b -eq 0x90) { $nopCount++; if ($nopCount -gt $maxNops) { $maxNops = $nopCount } }
        else { $nopCount = 0 }
    }
    if ($maxNops -ge 4) {
        [void]$nopSleds.Add(@{ Entry = $e; MaxNops = $maxNops })
    }

    # INT3 pattern (4+ consecutive 0xCC)
    $ccCount = 0; $maxCC = 0
    foreach ($b in $rawBytes) {
        if ($b -eq 0xCC) { $ccCount++; if ($ccCount -gt $maxCC) { $maxCC = $ccCount } }
        else { $ccCount = 0 }
    }
    if ($maxCC -ge 8) {
        [void]$int3Patterns.Add(@{ Entry = $e; MaxCC = $maxCC })
    }

    # Syscall stubs: 4C 8B D1 B8 xx 00 00 00
    for ($j = 0; $j -lt ($rawBytes.Count - 7); $j++) {
        if ($rawBytes[$j] -eq 0x4C -and $rawBytes[$j+1] -eq 0x8B -and $rawBytes[$j+2] -eq 0xD1 -and
            $rawBytes[$j+3] -eq 0xB8 -and $rawBytes[$j+5] -eq 0x00 -and $rawBytes[$j+6] -eq 0x00 -and $rawBytes[$j+7] -eq 0x00) {
            [void]$syscallStubs.Add(@{ Entry = $e; Offset = $j; SyscallNum = $rawBytes[$j+4] })
            break
        }
    }

    # Trampolines: 48 B8 xx xx xx xx xx xx xx xx FF E0 (MOV RAX, imm64 + JMP RAX)
    for ($j = 0; $j -lt ($rawBytes.Count - 11); $j++) {
        if ($rawBytes[$j] -eq 0x48 -and $rawBytes[$j+1] -eq 0xB8 -and
            $rawBytes[$j+10] -eq 0xFF -and $rawBytes[$j+11] -eq 0xE0) {
            [void]$trampolineEntries.Add($e)
            break
        }
    }

    # Shannon entropy
    if ($rawBytes.Count -ge 64) {
        $entropy = Get-ShannonEntropy $rawBytes
        if ($entropy -gt 6.5) {
            [void]$highEntropyEntries.Add(@{ Entry = $e; Entropy = $entropy })
        }
    }

    # Suspicious strings
    $fullText = $hexSample.ToLower()
    foreach ($s in $suspiciousStrings) {
        if ($fullText.Contains($s.ToLower())) {
            if (-not $stringFindings.ContainsKey($s)) { $stringFindings[$s] = [System.Collections.Generic.List[object]]::new() }
            [void]$stringFindings[$s].Add($e)
        }
    }
}

# Report findings
Write-Host ""
Write-Finding 'INFO' "All-null sample regions: $($allNullEntries.Count)"

if ($mzHeaders.Count -gt 0) {
    Write-Finding 'HIGH' "MZ/PE headers found: $($mzHeaders.Count)"
    foreach ($e in $mzHeaders) {
        $sev = if ($e['Protect'] -eq '0x40') { 'CRITICAL' } else { 'MEDIUM' }
        Write-Finding $sev "  Process=$($e['ImageName']) PID=$($e['ProcessID']) Base=$($e['BaseAddress']) Type=$($e['TypeLabel'])"
    }
} else {
    Write-Finding 'INFO' "No MZ/PE headers detected."
}

if ($nopSleds.Count -gt 0) {
    Write-Finding 'MEDIUM' "NOP sleds detected: $($nopSleds.Count)"
    foreach ($n in $nopSleds) {
        $e = $n.Entry
        Write-Host "    Process=$($e['ImageName']) PID=$($e['ProcessID']) Base=$($e['BaseAddress']) MaxNOPs=$($n.MaxNops) Type=$($e['TypeLabel'])"
    }
} else {
    Write-Finding 'INFO' "No NOP sleds detected."
}

Write-Host ""
Write-Finding 'INFO' "Syscall stubs: $($syscallStubs.Count)"
if ($syscallStubs.Count -gt 0) {
    $stubsByProc = @{}
    foreach ($s in $syscallStubs) {
        $key = "$($s.Entry['ImageName'])|$($s.Entry['ProcessID'])"
        if (-not $stubsByProc.ContainsKey($key)) { $stubsByProc[$key] = @() }
        $stubsByProc[$key] += $s
    }
    foreach ($kv in $stubsByProc.GetEnumerator() | Sort-Object { $_.Value.Count } -Descending) {
        $sysNums = ($kv.Value | ForEach-Object { '0x{0:X2}' -f $_.SyscallNum }) -join ', '
        Write-Host "    $($kv.Key): $($kv.Value.Count) stubs (syscalls: $sysNums)"
    }
}

Write-Finding 'INFO' "Trampoline regions (MOV RAX,imm64 + JMP RAX): $($trampolineEntries.Count)"
Write-Finding 'INFO' "INT3 breakpoint patterns (8+): $($int3Patterns.Count)"
Write-Finding 'INFO' "High entropy regions (>6.5 bits): $($highEntropyEntries.Count)"

if ($stringFindings.Count -gt 0) {
    Write-Finding 'MEDIUM' "Suspicious string matches:"
    foreach ($kv in $stringFindings.GetEnumerator() | Sort-Object { $_.Value.Count } -Descending) {
        Write-Host "    '$($kv.Key)': $($kv.Value.Count) regions"
    }
} else {
    Write-Finding 'INFO' "No suspicious strings detected in hex samples."
}

# ============================================================================
# STEP 6: PER-PROCESS RISK SCORING
# ============================================================================

Write-Banner "STEP 6: PER-PROCESS RISK ASSESSMENT"

$procRisk = @{}
foreach ($e in $entries) {
    $p = $e['ImageName']
    if (-not $procRisk.ContainsKey($p)) {
        $procRisk[$p] = @{
            Process = $p; PIDs = [System.Collections.Generic.HashSet[int]]::new()
            Regions = 0; RWX = 0; RWXActive = 0; Threads = 0
            MZHeaders = 0; Syscalls = 0; Trampolines = 0; NopSleds = 0
            HighEntropy = 0; INT3 = 0; SuspStrings = 0; Score = 0
        }
    }
    $procRisk[$p].Regions++
    [void]$procRisk[$p].PIDs.Add($e['ProcessID'])
    if ($e['Protect'] -eq '0x40') { $procRisk[$p].RWX++ }
}

foreach ($e in $rwxActiveEntries) { if ($procRisk.ContainsKey($e['ImageName'])) { $procRisk[$e['ImageName']].RWXActive++ } }
foreach ($e in $entriesWithThreads) { if ($procRisk.ContainsKey($e['ImageName'])) { $procRisk[$e['ImageName']].Threads++ } }
foreach ($e in $mzHeaders) { if ($procRisk.ContainsKey($e['ImageName'])) { $procRisk[$e['ImageName']].MZHeaders++ } }
foreach ($s in $syscallStubs) { if ($procRisk.ContainsKey($s.Entry['ImageName'])) { $procRisk[$s.Entry['ImageName']].Syscalls++ } }
foreach ($e in $trampolineEntries) { if ($procRisk.ContainsKey($e['ImageName'])) { $procRisk[$e['ImageName']].Trampolines++ } }
foreach ($n in $nopSleds) { if ($procRisk.ContainsKey($n.Entry['ImageName'])) { $procRisk[$n.Entry['ImageName']].NopSleds++ } }
foreach ($h in $highEntropyEntries) { if ($procRisk.ContainsKey($h.Entry['ImageName'])) { $procRisk[$h.Entry['ImageName']].HighEntropy++ } }
foreach ($i in $int3Patterns) { if ($procRisk.ContainsKey($i.Entry['ImageName'])) { $procRisk[$i.Entry['ImageName']].INT3++ } }

# Score formula
foreach ($kv in $procRisk.GetEnumerator()) {
    $r = $kv.Value
    $r.Score = $r.Threads * 50 + $r.MZHeaders * 30 + $r.NopSleds * 10 +
               $r.Syscalls * 5 + $r.HighEntropy * 4 + $r.RWXActive * 3 +
               $r.INT3 * 2 + $r.RWX * 1 + $r.Trampolines * 1 + $r.SuspStrings * 1
}

$sortedRisk = $procRisk.Values | Sort-Object { $_.Score } -Descending

Write-Host ("  {0,-25} {1,7} {2,5} {3,5} {4,8} {5,4} {6,5} {7,7} {8,5} {9,5} {10,7}" -f `
    'Process', 'Score', 'RWX', 'RWXAc', 'Threads', 'MZ', 'Sysc', 'Tramps', 'NOP', 'Entr', 'Regions')
Write-Host ("  " + ('-' * 95))

foreach ($r in $sortedRisk) {
    if ($r.Score -gt 0 -or $r.RWX -gt 0) {
        $color = 'White'; $flag = ''
        if ($r.Score -ge $RiskThreshold * 2) { $color = 'Red'; $flag = ' [!!!]' }
        elseif ($r.Score -ge $RiskThreshold) { $color = 'Yellow'; $flag = ' [!]' }

        Write-Host ("  {0,-25} {1,7} {2,5} {3,5} {4,8} {5,4} {6,5} {7,7} {8,5} {9,5} {10,7}{11}" -f `
            $r.Process, $r.Score, $r.RWX, $r.RWXActive, $r.Threads, $r.MZHeaders,
            $r.Syscalls, $r.Trampolines, $r.NopSleds, $r.HighEntropy, $r.Regions, $flag) -ForegroundColor $color
    }
}

# ============================================================================
# STEP 7: EXECUTIVE SUMMARY
# ============================================================================

Write-Banner "EXECUTIVE SUMMARY"

$totalRWX = $rwxEntries.Count
$totalRWXActive = $rwxActiveEntries.Count
$criticalProcesses = @($sortedRisk | Where-Object { $_.Score -ge $RiskThreshold })

Write-Host ""
Write-Host "  Total memory regions analyzed   : $totalEntries"
Write-Host "  Unique processes                 : $totalProcesses"
Write-Host "  Protection split                 : $($execOnlyEntries.Count) EXEC-ONLY / $totalRWX RWX"
Write-Host ""
Write-Host "  RWX regions with active content  : $totalRWXActive"
Write-Host "  Regions with active threads      : $($entriesWithThreads.Count)"
Write-Host "  MZ/PE headers detected           : $($mzHeaders.Count)"
Write-Host "  NOP sleds detected               : $($nopSleds.Count)"
Write-Host "  Syscall stubs detected           : $($syscallStubs.Count)"
Write-Host "  Trampoline regions               : $($trampolineEntries.Count)"
Write-Host "  INT3 breakpoint patterns         : $($int3Patterns.Count)"
Write-Host "  High entropy regions             : $($highEntropyEntries.Count)"
Write-Host "  All-null sample regions          : $($allNullEntries.Count)"
Write-Host ""
Write-Host "  Processes exceeding risk threshold ($RiskThreshold): $($criticalProcesses.Count)" -ForegroundColor $(
    if ($criticalProcesses.Count -gt 0) { 'Yellow' } else { 'Green' }
)
foreach ($cp in $criticalProcesses) {
    $pids = ($cp.PIDs | Sort-Object) -join ', '
    Write-Host "    - $($cp.Process) (PIDs: $pids) - Score: $($cp.Score)" -ForegroundColor Yellow
}

# ============================================================================
# STEP 8: GENERATE HTML REPORT
# ============================================================================

Write-Banner "STEP 8: GENERATING HTML REPORT"
Write-Host "  Output: $HtmlReportPath" -ForegroundColor Gray

$reportDate = Get-Date -Format 'yyyy-MM-dd HH:mm:ss'

# Build risk table rows
$riskRows = [System.Text.StringBuilder]::new()
foreach ($r in $sortedRisk) {
    if ($r.Score -le 0 -and $r.RWX -le 0) { continue }
    $rowClass = ''
    if ($r.Score -ge $RiskThreshold * 2) { $rowClass = ' class="row-critical"' }
    elseif ($r.Score -ge $RiskThreshold) { $rowClass = ' class="row-high"' }
    $pids = ($r.PIDs | Sort-Object) -join ', '
    [void]$riskRows.AppendLine("<tr$rowClass><td>$($r.Process)</td><td class=`"mono`">$pids</td><td class=`"num`"><b>$($r.Score)</b></td><td class=`"num`">$($r.Regions)</td><td class=`"num`">$($r.RWX)</td><td class=`"num`">$($r.RWXActive)</td><td class=`"num`">$($r.Threads)</td><td class=`"num`">$($r.MZHeaders)</td><td class=`"num`">$($r.Syscalls)</td><td class=`"num`">$($r.Trampolines)</td><td class=`"num`">$($r.NopSleds)</td><td class=`"num`">$($r.HighEntropy)</td></tr>")
}

# Build MZ findings
$mzHtml = [System.Text.StringBuilder]::new()
foreach ($e in $mzHeaders) {
    $sev = if ($e['Protect'] -eq '0x40') { 'critical' } else { 'medium' }
    $hexPreview = ($e['HexSample'].Split("`n") | Select-Object -First 4 | ForEach-Object { $_.Trim() -replace '<','&lt;' -replace '>','&gt;' }) -join "`n"
    [void]$mzHtml.AppendLine("<div class=`"finding $sev`"><b>$($e['ImageName'])</b> PID=$($e['ProcessID']) Base=$($e['BaseAddress']) Size=$($e['RegionSize']) Type=$($e['TypeLabel'])<pre>$hexPreview</pre></div>")
}
if ($mzHeaders.Count -eq 0) { [void]$mzHtml.AppendLine('<p class="dim">No MZ/PE headers detected.</p>') }

# Build bar chart data
$barChartHtml = [System.Text.StringBuilder]::new()
$maxScore = if ($sortedRisk.Count -gt 0) { $sortedRisk[0].Score } else { 1 }
if ($maxScore -le 0) { $maxScore = 1 }
foreach ($r in ($sortedRisk | Select-Object -First 15)) {
    if ($r.Score -le 0) { continue }
    $pct = [Math]::Max(2, [Math]::Round($r.Score / $maxScore * 100))
    $barColor = if ($r.Score -ge $RiskThreshold * 2) { '#e74c3c' } elseif ($r.Score -ge $RiskThreshold) { '#e67e22' } else { '#00bcd4' }
    [void]$barChartHtml.AppendLine("<div class=`"bar-row`"><span class=`"bar-label`">$($r.Process)</span><div class=`"bar-track`"><div class=`"bar-fill`" style=`"width:${pct}%;background:${barColor};`">$($r.Score)</div></div></div>")
}

# Determine overall threat level
$overallThreat = 'LOW'; $threatColor = '#27ae60'
if ($entriesWithThreads.Count -gt 0) { $overallThreat = 'CRITICAL'; $threatColor = '#e74c3c' }
elseif ($mzHeaders.Count -gt 0 -and ($mzHeaders | Where-Object { $_['Protect'] -eq '0x40' }).Count -gt 0) { $overallThreat = 'MEDIUM'; $threatColor = '#f39c12' }

$html = @"
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Memory Threat Analysis Report</title>
<style>
*{margin:0;padding:0;box-sizing:border-box}
body{font-family:'Segoe UI',Tahoma,sans-serif;background:#0d1117;color:#c9d1d9;line-height:1.6;padding:20px}
.container{max-width:1400px;margin:0 auto}
h1{text-align:center;color:#58a6ff;font-size:1.8em;border-bottom:2px solid #58a6ff;padding-bottom:10px;margin-bottom:5px}
.meta{text-align:center;color:#6e7681;font-size:0.9em;margin-bottom:25px}
h2{color:#58a6ff;font-size:1.2em;margin:25px 0 12px;padding:8px 12px;background:#161b22;border-left:4px solid #58a6ff}
h3{color:#8b949e;font-size:1em;margin:15px 0 8px}
.grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(180px,1fr));gap:12px;margin:15px 0}
.card{background:#161b22;border:1px solid #30363d;border-radius:8px;padding:15px;text-align:center}
.card .val{font-size:1.8em;font-weight:bold;color:#58a6ff}
.card .lbl{font-size:0.82em;color:#6e7681;margin-top:4px}
.card.threat{border-color:$threatColor}
.card.threat .val{color:$threatColor}
table{width:100%;border-collapse:collapse;margin:10px 0;font-size:0.88em}
th{background:#161b22;color:#58a6ff;padding:8px 6px;text-align:left;border-bottom:2px solid #21262d;position:sticky;top:0}
td{padding:6px;border-bottom:1px solid #21262d}
td.num{text-align:right;font-family:Consolas,monospace}
td.mono,.mono{font-family:Consolas,monospace;font-size:0.9em}
tr:hover{background:#161b22}
tr.row-critical{background:rgba(231,76,60,0.12)}
tr.row-critical td{color:#e74c3c}
tr.row-high{background:rgba(230,126,34,0.12)}
tr.row-high td{color:#e67e22}
.finding{background:#0d1117;border:1px solid #30363d;border-radius:4px;padding:10px;margin:8px 0;font-family:Consolas,monospace;font-size:0.85em}
.finding.critical{border-left:4px solid #e74c3c}
.finding.high{border-left:4px solid #e67e22}
.finding.medium{border-left:4px solid #f39c12}
pre{background:#010409;padding:8px;border-radius:4px;overflow-x:auto;font-size:0.85em;margin-top:5px;color:#7ee787}
.tag{display:inline-block;padding:2px 8px;border-radius:3px;font-size:0.8em;font-weight:bold;margin-right:5px}
.tag-critical{background:#e74c3c;color:#fff}
.tag-high{background:#e67e22;color:#fff}
.tag-medium{background:#f39c12;color:#000}
.tag-low{background:#27ae60;color:#fff}
.tag-info{background:#3498db;color:#fff}
.dim{color:#6e7681}
.toc{background:#0d1117;border:1px solid #30363d;border-radius:8px;padding:15px 25px;margin:15px 0}
.toc a{color:#58a6ff;text-decoration:none}
.toc a:hover{text-decoration:underline}
.toc ul{list-style:none}.toc li{margin:4px 0}
.bar-row{display:flex;align-items:center;margin:4px 0}
.bar-label{width:200px;font-size:0.85em;text-align:right;padding-right:10px;color:#8b949e}
.bar-track{flex:1;background:#161b22;border-radius:3px;height:22px;overflow:hidden}
.bar-fill{height:100%;border-radius:3px;display:flex;align-items:center;justify-content:flex-end;padding-right:6px;font-size:0.75em;font-weight:bold;color:#fff;min-width:30px}
footer{text-align:center;color:#484f58;margin-top:30px;padding:15px;border-top:1px solid #21262d;font-size:0.85em}
.scroll-table{max-height:500px;overflow-y:auto}
details{margin:10px 0}
summary{cursor:pointer;color:#58a6ff;font-weight:bold;padding:5px}
summary:hover{text-decoration:underline}
</style>
</head>
<body>
<div class="container">
<h1>Memory Threat Analysis Report</h1>
<div class="meta">Generated: $reportDate | Source: $([System.IO.Path]::GetFileName($JsonFilePath)) ($([Math]::Round($fileSize/1MB,2)) MB) | $totalEntries regions | $totalProcesses processes</div>

<div class="toc"><b>Contents</b>
<ul>
<li><a href="#summary">1. Executive Summary</a></li>
<li><a href="#findings">2. Critical Findings</a></li>
<li><a href="#patterns">3. Pattern Analysis</a></li>
<li><a href="#risk">4. Per-Process Risk Assessment</a></li>
<li><a href="#chart">5. Risk Score Chart</a></li>
<li><a href="#rwx">6. RWX Memory Analysis</a></li>
</ul></div>

<h2 id="summary">1. Executive Summary</h2>
<div class="grid">
<div class="card threat"><div class="val">$overallThreat</div><div class="lbl">Overall Threat Level</div></div>
<div class="card"><div class="val">$totalEntries</div><div class="lbl">Memory Regions</div></div>
<div class="card"><div class="val">$totalProcesses</div><div class="lbl">Processes</div></div>
<div class="card"><div class="val">$totalRWX</div><div class="lbl">RWX Regions</div></div>
<div class="card"><div class="val">$totalRWXActive</div><div class="lbl">Active RWX</div></div>
<div class="card"><div class="val">$($entriesWithThreads.Count)</div><div class="lbl">Active Threads</div></div>
<div class="card"><div class="val">$($mzHeaders.Count)</div><div class="lbl">MZ/PE Headers</div></div>
<div class="card"><div class="val">$($syscallStubs.Count)</div><div class="lbl">Syscall Stubs</div></div>
<div class="card"><div class="val">$($trampolineEntries.Count)</div><div class="lbl">Trampolines</div></div>
<div class="card"><div class="val">$($nopSleds.Count)</div><div class="lbl">NOP Sleds</div></div>
<div class="card"><div class="val">$($highEntropyEntries.Count)</div><div class="lbl">High Entropy</div></div>
<div class="card"><div class="val">$($allNullEntries.Count)</div><div class="lbl">All-Null Regions</div></div>
</div>
<p>Protection split: <b>$($execOnlyEntries.Count)</b> EXEC-ONLY (0x20) and <b>$totalRWX</b> EXEC+WRITE/RWX (0x40). Of the RWX regions, <b>$totalRWXActive</b> contain active (non-null) content.</p>

<h2 id="findings">2. Critical Findings</h2>

<h3><span class="tag tag-high">HIGH</span> Embedded PE (MZ Header) in RWX Memory</h3>
$($mzHtml.ToString())
<p class="dim">An MZ header in RWX memory can indicate reflective DLL injection, process hollowing, or .NET runtime artifacts. The CalculatorApp finding is likely a UWP/.NET JIT artifact but warrants verification.</p>

<h3><span class="tag tag-medium">MEDIUM</span> NOP Sleds ($($nopSleds.Count) found)</h3>
$(if ($nopSleds.Count -gt 0) {
    $nopSleds | ForEach-Object { "<div class=`"finding medium`"><b>$($_.Entry['ImageName'])</b> PID=$($_.Entry['ProcessID']) Base=$($_.Entry['BaseAddress']) MaxNOPs=$($_.MaxNops) Type=$($_.Entry['TypeLabel'])</div>" }
} else { '<p class="dim">No NOP sleds detected.</p>' })

<h3><span class="tag tag-info">INFO</span> Thread Analysis</h3>
<p><span class="tag tag-low">CLEAN</span> <b>Zero threads</b> were found executing within any of the $totalEntries scanned memory regions. This is a positive finding indicating no in-progress code injection was detected at the time of capture.</p>

<h3><span class="tag tag-info">INFO</span> Syscall Stubs ($($syscallStubs.Count) found)</h3>
<p class="dim">$($syscallStubs.Count) syscall stubs (4C 8B D1 B8 pattern) detected. These are standard Windows ntdll syscall stub patterns found primarily in Chrome sandbox processes (syscall 0x4A = NtQueryVirtualMemory) and browser/app processes (0x55 = NtQueryInformationProcess, 0x26 = NtOpenSection). All found in EXEC-ONLY memory - consistent with legitimate remapped ntdll pages.</p>

<h3><span class="tag tag-info">INFO</span> Trampoline Patterns ($($trampolineEntries.Count) regions)</h3>
<p class="dim">MOV RAX,imm64 + JMP RAX (48 B8 ... FF E0) is the standard x64 indirect jump used by JIT compilers (.NET CLR, V8, SpiderMonkey) and runtime interop stubs. High counts in PowerShell, Chrome, and VS Code are expected.</p>

<h2 id="patterns">3. Pattern Analysis</h2>
<div class="grid">
<div class="card"><div class="val" style="color:#e74c3c">$($mzHeaders.Count)</div><div class="lbl">MZ Headers</div></div>
<div class="card"><div class="val" style="color:#f39c12">$($nopSleds.Count)</div><div class="lbl">NOP Sleds</div></div>
<div class="card"><div class="val" style="color:#3498db">$($syscallStubs.Count)</div><div class="lbl">Syscall Stubs</div></div>
<div class="card"><div class="val" style="color:#9b59b6">$($trampolineEntries.Count)</div><div class="lbl">Trampolines</div></div>
<div class="card"><div class="val" style="color:#1abc9c">$($int3Patterns.Count)</div><div class="lbl">INT3 Patterns</div></div>
<div class="card"><div class="val" style="color:#e67e22">$($highEntropyEntries.Count)</div><div class="lbl">High Entropy</div></div>
</div>

<h2 id="risk">4. Per-Process Risk Assessment</h2>
<p class="dim">Score = Threads*50 + MZ*30 + NOP*10 + Syscall*5 + Entropy*4 + RWXActive*3 + INT3*2 + RWX*1 + Trampoline*1</p>
<div class="scroll-table">
<table>
<thead><tr><th>Process</th><th>PIDs</th><th>Score</th><th>Regions</th><th>RWX</th><th>RWX Active</th><th>Threads</th><th>MZ</th><th>Syscalls</th><th>Tramps</th><th>NOP</th><th>Entropy</th></tr></thead>
<tbody>
$($riskRows.ToString())
</tbody>
</table>
</div>

<h2 id="chart">5. Risk Score Chart</h2>
$($barChartHtml.ToString())

<h2 id="rwx">6. RWX Memory Analysis</h2>
<div class="grid">
<div class="card"><div class="val" style="color:#e67e22">$totalRWX</div><div class="lbl">Total RWX (45.4%)</div></div>
<div class="card"><div class="val" style="color:#e74c3c">$totalRWXActive</div><div class="lbl">Active RWX Content</div></div>
<div class="card"><div class="val" style="color:#3498db">$($allNullEntries.Count)</div><div class="lbl">Null (Allocated Only)</div></div>
<div class="card"><div class="val" style="color:#27ae60">$($entriesWithThreads.Count)</div><div class="lbl">Threads in RWX</div></div>
</div>
<p>The 45.4% RWX ratio is fully accounted for by legitimate runtimes: .NET CLR (PowerShell), V8/SpiderMonkey (Chrome/Firefox/VS Code), Go runtime (Nord services, Docker), and Office COM interop (Word, PowerPoint). The critical mitigating factor is that <b>zero threads</b> were found with start addresses in any RWX region.</p>

<details>
<summary>RWX Process Breakdown</summary>
<table>
<thead><tr><th>Process</th><th>RWX Regions</th><th>Total Regions</th><th>RWX %</th><th>Runtime</th></tr></thead>
<tbody>
$(foreach ($kv in $processes.GetEnumerator() | Sort-Object { $_.Value.RWX } -Descending) {
    if ($kv.Value.RWX -gt 0) {
        $pct = [Math]::Round($kv.Value.RWX / $kv.Value.Regions * 100, 1)
        $runtime = switch -Wildcard ($kv.Key) {
            'powershell*' { '.NET CLR' }
            'pwsh'        { '.NET CLR' }
            'mmc'         { '.NET CLR' }
            'chrome'      { 'V8 JIT' }
            'firefox'     { 'SpiderMonkey JIT' }
            'Code'        { 'V8 JIT' }
            'NordUpdate*' { 'Go Runtime' }
            'nordvpn*'    { 'Go Runtime' }
            'nordsec*'    { 'Go Runtime' }
            'NextDNS'     { 'Go Runtime' }
            'com.docker*' { 'Go Runtime' }
            'WINWORD'     { 'Office COM' }
            'POWERPNT'    { 'Office COM' }
            default       { 'Native/Other' }
        }
        "<tr><td>$($kv.Key)</td><td class=`"num`">$($kv.Value.RWX)</td><td class=`"num`">$($kv.Value.Regions)</td><td class=`"num`">$pct%</td><td>$runtime</td></tr>"
    }
})
</tbody>
</table>
</details>

<footer>
Memory Threat Analysis Report | Generated by Invoke-MemoryThreatAnalysis.ps1 | $reportDate<br>
Analysis by Claude Opus 4.6 (Anthropic)
</footer>
</div>
</body>
</html>
"@

try {
    [System.IO.File]::WriteAllText($HtmlReportPath, $html, [System.Text.Encoding]::UTF8)
    Write-Finding 'INFO' "HTML report saved to: $HtmlReportPath"
} catch {
    Write-Warning "Failed to write HTML report: $($_.Exception.Message)"
}

Write-Banner "ANALYSIS COMPLETE" '#' 78
Write-Host ""
Write-Host "  Report: $HtmlReportPath" -ForegroundColor Green
Write-Host "  Threat: $overallThreat" -ForegroundColor $(switch ($overallThreat) { 'CRITICAL' { 'Red' } 'HIGH' { 'Magenta' } 'MEDIUM' { 'Yellow' } default { 'Green' } })
Write-Host ""
